#include <string>
#include "Analyze.h"
#include <asm/ptrace.h>
#include "VMState.h"
#include "HistoryTree.h"
#include "thinctrl.h"
#include "common_idata.h"
// #include "com.h" /*from seam manager*/
#include "seam.h"
#include "pageManager.h"
#include "tdx_local_data.h"
#include <cstring>

struct iData *tdx_sp_ins;

using namespace std;
using namespace Dyninst;
using namespace ParseAPI;
using namespace InstructionAPI;

extern bool endCurrentPath;
extern PATH_END_RSN endCurrentPathReason;
extern struct servReq *sreq;

struct MacReg*  m_regs;
std::map<ulong, ulong> seam_va_pa_map;
std::map<ulong, ulong> seam_pa_va_map;
std::map<ulong /*buf base*/, ulong /*conc adr from seeded*/> sym_buf_bases;

int             dispatch_count = 0;
int is_se = 0;

uint8_t sym_buffer[4096];
#define PTE_TO_PA_MASK		0xfffffff000UL
#define PG_SZ_4K            0x1000UL
#define PTE_PRESENT_MASK    0x1

bool epml5_mapped_once = false;
ulong updated_sept_page_seam_va = 0;
ulong td_sept_page_seam_va[5];

bool is_epte_defined = false;

ulong last_path = 0;
int scall_failed_count = 0; 

ulong lp_keyhole_va_base;
ulong lp_khole_edit_base_va;

int sym_buf_count = 1;
ulong tdx_call_ret_adr = 0;
bool path_to_end_at_next_ins  = false;

KVExprPtr pte_expr(nullptr);

CAnalyze::CAnalyze(VMState *VM, EveMeta* meta) {
    m_VM = VM;
    execData = new ExecData;
    execData->insn_count = 0; 
    execData->is_next_ins_seamret = false;
    execData->current_path = 0;

    execData->last_conc_exprptr = NULL;
    execData->last_conc_ins_count = 0;

    execProfile = new ExecProfile;
    execProfile->executionMode = 0; /*DEFAULT, single pat hseeded*/
    execProfile->terminationMode = 0; /*DEFAULT, terminate at stack balance, function return*/
    execProfile->terminate_ins_count = 0;

}

CAnalyze::~CAnalyze() {
}

void CAnalyze::setExecProfileSinglePath(){
    std::cout << "setExecProfileSinglePath" << std::endl;
    execProfile->executionMode = EXEC_MD_SINGLE_PATH_SEDED;
    execProfile->terminationMode = END_AT_ANA_REQUEST;
    execProfile->startIncCount = 0;
}

void CAnalyze::setExecProfileMultiPath(){
    std::cout << "setExecProfileMultiPath" << std::endl;
    execProfile->executionMode = EXEC_MD_START_PATH_SEARCH_AT_INS_COUNT;
    // execProfile->startRip = rip;
    // execProfile->startIncCount = 2089;
    execProfile->startIncCount = 0;
    
    // execProfile->terminationMode = END_AT_GIVEN_INS_COUNT;
    // execProfile->terminate_ins_count = 100;
}   

ulong CAnalyze::getSeedFromMemory(ulong adr){

    bool res;
    MemValue mv;

    mv.size = 8;
    mv.addr = adr;
    mv.bsym = false;
    mv.isSymList = false;

    res = m_VM->readMemory (mv);
    assert(res);
    assert(!mv.bsym);

    return mv.i64;
}

ulong CAnalyze::findKeyHoleVa(ulong pa){

    // ulong lp_khole_edit_base_va = sreq->khole_edit_start_seam_va + sreq->current_lp*8*128;
    int lp_keyhole_idx = 0;
    bool res;
    MemValue mv;
    ulong seam_va = 0;
    ulong khole_pte;

    if(pa == 0x0){
        return 0;
    }

    while(lp_keyhole_idx < 128){

        khole_pte = *(ulong *)(lp_khole_edit_base_va + lp_keyhole_idx*8);
        // std::cout << "khole_pte:0x" << khole_pte << std::endl;

        if((khole_pte & PTE_PRESENT_MASK) && ((khole_pte & PTE_TO_PA_MASK) == pa)){
                seam_va = keyholeIdxToVa(lp_keyhole_idx, pa);
                // std::cout << "sEPTE: 0x" << std::hex << khole_pte << std::endl;
                // std::cout << "seam_va: 0x" << std::hex << seam_va << std::endl;
                return seam_va;
        }

        lp_keyhole_idx++;
    }


    std::cout << "end\n";
    return seam_va;
}

ulong CAnalyze::keyholeIdxToVa(int khole_idx, ulong pa){

    ulong seam_va = lp_keyhole_va_base + khole_idx*(PG_SZ_4K);
    seam_pa_va_map.insert({pa, seam_va});
    seam_va_pa_map.insert({seam_va, pa});
    std::cout << "pa: 0x" << std::hex << pa << "\t seam va: 0x" << seam_va << std::endl;

    return seam_va;
}

bool CAnalyze::validateKholeEditRange(ulong adr){
    if((adr < lp_khole_edit_base_va) || (adr) >= (lp_khole_edit_base_va + 128*8)){
        std::cout << "key hole edit access out off range for current LP !" << std::endl;
        assert(0);
    }
    return false;
}

bool CAnalyze::isKholeEditAddress(ulong adr){
    std::cout << "adr: 0x" << std::hex << adr << std::endl;
    if((adr >> 63) != 1){ /*khole edit mapping in the lower half of 48bit adr space*/
        std::cout << "khole-edit adr: 0x" << std::hex << adr << std::endl;
        return true;
    }
    return false;
}

bool CAnalyze::validateKholeRange(ulong adr){

    if((adr < lp_keyhole_va_base) || (adr >= (lp_keyhole_va_base + PG_SZ_4K*128))){
        std::cout << "khole access, out of LP khole renge" << std::endl;
        assert(0);
    }
    return false;
}

bool CAnalyze::isKholeAddress(ulong adr){

    if((adr >= sreq->khole_start) && (adr < sreq->mod_data_rgn_start)){
        std::cout << "khole access: 0x" << std::hex << adr << std::endl;
        return true;
    }
    return false;
}

bool CAnalyze::isModuleLibSymAccess(ulong adr){
    
    if((adr >= sreq->mod_code_rgn_start) && (adr < sreq->mod_stack_rgn_start)){
        std::cout << "Module lib symbol access: 0x" << std::hex << adr << std::endl;
        return true;
    }
    return false;
}

bool CAnalyze::findMapedKholes(){

    // updated_sept_page_seam_va = findKeyHoleVa(sreq->updated_sept_page);
    // td_epml5_seam_va = findKeyHoleVa(sreq->td_epml5_pa);
    // td_epml4_seam_va = findKeyHoleVa(sreq->td_epml4_pa);
    // td_epdpt_seam_va = findKeyHoleVa(sreq->td_epdpt_pa);
    // td_epd_seam_va = findKeyHoleVa(sreq->td_epd_pa);
    // td_ept_seam_va = findKeyHoleVa(sreq->td_ept_pa);

    td_sept_page_seam_va[4] = findKeyHoleVa(sreq->td_epml5_pa);
    td_sept_page_seam_va[3] = findKeyHoleVa(sreq->td_epml4_pa);
    td_sept_page_seam_va[2] = findKeyHoleVa(sreq->td_epdpt_pa);
    td_sept_page_seam_va[1] = findKeyHoleVa(sreq->td_epd_pa);    

    std::cout << "td_epml5_seam_va\t:0x" << std::hex << td_sept_page_seam_va[4] << std::endl;
    std::cout << "td_epml4_seam_va\t:0x" << std::hex << td_sept_page_seam_va[3] << std::endl;
    std::cout << "td_epdpt_seam_va\t:0x" << std::hex << td_sept_page_seam_va[2] << std::endl;
    std::cout << "td_epd_seam_va\t:0x" << std::hex << td_sept_page_seam_va[1] << std::endl;
    // std::cout << "td_ept_seam_va\t:0x" << std::hex << td_ept_seam_va << std::endl;

    return true;

}


/*---sanitiy checks and post processing --------------------------------------------------------------------------------START*/
void CAnalyze::doEndOfPathChecks(int scall_status){

    std::cout << "doEndOfPAthChecks ....................." << std::endl;
    std::set<unsigned long> sym_range;
    std::string s_name = "gpa_B4_7";
    
    switch (scall_status)
    {
        case PATH_SEAMRET_FAIL: /*scall fail*/
        {
                
        }break;
        case PATH_SEAMRET_PASS: /*scall success*/
        {
            /*Solving the path constraint iteratively to get the full range of ePTE idx.
            We do not need this as this is a bruite force technique.
            sym_range = a_EFlagsMgr->SolveConstraint(a_EFlagsMgr->m_Constraint, s_name);

            std::cout << "range of ept_idx: ";
            for (unsigned long val: sym_range){
                std::cout << std::hex << ((val >> 16) & 0x1ff) << ", ";
            }
            std::cout << std::endl;*/
        } break;
        default:
            break;
    }
    
    /*Checking for all modified data can tell us which regions have been changed. But since we do not 
    know what those memory objects are, given a modified address we can not reason
    m_Thin->m_PM->checkModifiedData();*/

    /*check sEPT data, symbolic buffer----------*/
    if(updated_sept_page_seam_va != 0){
        std::cout << "checking sEPT page symbolic buffer contents ..." << std::endl;
        int sept_idx = 0;
        bool res;

        MemValue mv2 ;
        mv2.size = 8 ;

        /*read the exact 8 byte block that is expected to be modified*/
        mv2.addr = updated_sept_page_seam_va;
        mv2.bsym = false;
        mv2.isSymList = false;

        res = m_VM->readMemory (mv2);
        assert(res);
        if(mv2.bsym){
            assert(mv2.expr);
            std::cout << "Update expected sEPTE: ";
            mv2.expr->print();
            std::cout << std::endl;
        }
        else{
            std::cout << "Update expected sEPTE: 0x" << std::hex << mv2.i64 << std::endl;
        }

        /*check sEPT data, symbolic buffer*/
        while(sept_idx < 512){
            mv2.bsym = false;
            mv2.addr = updated_sept_page_seam_va + 8*sept_idx;
            // mv2.isSymList = false ;  ???
            res = m_VM->readMemory (mv2);
            assert(res);
            if(mv2.bsym){
                assert(mv2.expr);
                std::cout << "buffer offset: 0x" << std::hex << sept_idx*8; 
                std::cout << " 8 byte block: ";
                mv2.expr->print();
                std::cout << std::endl;
            }
            
            sept_idx +=1;
        }
    }


    // assert(scall_failed_count <= 1);

}
/*---sanitiy checks and post processing ----------------------------------------------------------------------------------END*/

void CAnalyze::endOfPathJobs(int scall_status){ //analysis at the end of each path

        path_to_end_at_next_ins = false;
        // td_pml5_seam_va_1 = 0;
        // td_pml5_seam_va_2 = 0;
        // td_pml5_seam_va = 0;
        epml5_mapped_once = false;
        updated_sept_page_seam_va = 0;
        is_epte_defined = false;
        last_path = execData->current_path;
        sym_buf_count = 1;

        seam_va_pa_map.clear();
        seam_pa_va_map.clear();
        sym_buf_bases.clear();
}

ulong CAnalyze::getKholePte(ulong rip){

    ulong pte;
    uint reg_idx;

    std::cout << "khe-ins: 0x" << sreq->keyhole_edit_ins_adr[0] << " 0x" << sreq->keyhole_edit_ins_adr[1] << std::endl;
    // assert(0);
    // if(eff_rip == 0xffffa00000009a9c){
    if(rip == sreq->keyhole_edit_ins_adr[0]){
        pte = m_regs->regs.rdx;
        reg_idx = x86_64::rdx;
        std::cout << "pte-x: 0x" << std::hex << pte << std::endl;
    }
    // else if(eff_rip == 0xffffa00000009d68){
    else if(rip == sreq->keyhole_edit_ins_adr[1]){
        pte = m_regs->regs.rsi;
        reg_idx = x86_64::rsi;
        std::cout << "pte-y: 0x" << std::hex << pte << std::endl;
    }
    else{
        assert(0);
    }

    //check if reg is symbolic
    bool res;
    RegValue rv;
    rv.indx = reg_idx;
    rv.size = 8;
    rv.isSymList = false;
    res = m_VM->readRegister(rv);
    assert(res);
    
    if(rv.bsym){
        assert(rv.expr);
        std::cout << "keyhole pte is symbolic" << std::endl;
        pte_expr = rv.expr;
        pte = m_VM->m_EFlagsMgr->ConcretizeExpression(rv.expr);
    }

    return pte;
}

uint CAnalyze::isKholePteSymbolic(ulong rip){

    ulong pte;
    bool res;

    std::cout << "khe-ins: 0x" << sreq->keyhole_edit_ins_adr[0] << " 0x" << sreq->keyhole_edit_ins_adr[1] << std::endl;
    // assert(0);
    // if(eff_rip == 0xffffa00000009a9c){
    RegValue rv;
    rv.size = 8;
    if(rip == sreq->keyhole_edit_ins_adr[0]){
        rv.indx = x86_64::rdx;
        // pte = m_regs->regs.rdx;
        // std::cout << "pte-x: 0x" << std::hex << pte << std::endl;
    }
    // else if(eff_rip == 0xffffa00000009d68){
    else if(rip == sreq->keyhole_edit_ins_adr[1]){
        rv.indx = x86_64::rsi;
        // pte = m_regs->regs.rsi;
        // std::cout << "pte-y: 0x" << std::hex << pte << std::endl;
    }
    else{
        assert(0);
    }

    res = m_VM->readRegister(rv);
    assert(res);
    if(rv.bsym){
        return rv.indx;
    }
    return 0;
}

void CAnalyze::createSymbolicMemory(ulong addr, ulong size, bool isSigned, bool hasSeed, long conVal, const char *name){

        /*check if the address is a boundary*/
        //todo
        assert((size > 0) && (size <= 8));
        assert(name);
        std::string sym_prefix = std::string(name);
        int count = 0;
        while(count < size){
            std::string sym_str = sym_prefix + "_" + std::to_string(count);
            const char* sym_name = sym_str.c_str();
            m_VM->createSYMemObject(addr + count, 1, 1, 1, *(uint8_t *)(addr + count), sym_name);
            count++;
        }
}


void CAnalyze::pageAccessSanitizer(ulong seam_va){
    std::cout << "pageAccessSanitizer\n";

    endCurrentPathReason = PATH_SEAMRET_PASS;
    endCurrentPath = true;
    std::cout << "\nEnd of cur path .... SEAMRET: SUCCESS" << std::endl;

    return;

    //get the khole edit entry from va
    // ulong khole_lp = ((seam_va & !(0xfffUL)) - sreq->khole_start_seam_va)/(PG_SZ_4K*128);
    ulong global_khole_idx = ((seam_va & ~(0xfffUL)) - sreq->khole_start_seam_va)/PG_SZ_4K;
    std::cout << "pageAccessSanitizer global_khole_idx " << std::dec << global_khole_idx << std::endl;

    ulong khole_edit_pte = *(ulong *)(sreq->khole_edit_start_seam_va + global_khole_idx*8);
    std::cout << "pageAccessSanitizer khole_edit_pte " << std::hex << khole_edit_pte << std::endl;

    ulong pfn = ((khole_edit_pte & ~(HKID_MASK)) & PTE_TO_PA_MASK) >> 12;
    ulong secure_page_idx = pfn - (TDX_TDMR0_START_PA >> 12);

    securePage *sp = (securePage *)&sreq->secPages[secure_page_idx];
    ulong page_owner_td = sp->mdata.td;
    ulong mod_running_td_ctx = sreq->td_owner_for_next_tdxcall;

    if(page_owner_td != mod_running_td_ctx){
        std::cout << "\npageAccessSanitizer ERROR: ILLEGAL page 0x" << std::hex << (pfn << 12) << " (Owner: TD_" << std::dec << page_owner_td << ") for currently serving TD: TD_" << mod_running_td_ctx << std::endl;
        endCurrentPathReason = PATH_ERROR;
        endCurrentPath = true;  
	}
}

void CAnalyze::pageAccessSanitizerSymbolic(){

    KVExprPtr e = execData->last_conc_exprptr;
    ulong v = execData->last_conc_expr_val;
    assert(v >> 63);

    ulong get_page_idx_shift = 12; /*shr 12 to divide by 4096*/
    ulong khole_edit_addr_conc;
    KVExprPtr global_khole_idx;
    KVExprPtr c1 = NULL;
    KVExprPtr c2 = NULL;
    KVExprPtr c3 = NULL;
    KVExprPtr c4 = NULL;
    KVExprPtr c5 = NULL;
    KVExprPtr c6 = NULL;

    KVExprPtr e1 = NULL;
    KVExprPtr e2 = NULL;
    KVExprPtr e3 = NULL;
    KVExprPtr khole_edit_addr = NULL;
    KVExprPtr mapped_pa = NULL;
    KVExprPtr e4 = NULL;
    KVExprPtr e5 = NULL;
    KVExprPtr e6 = NULL;

    KVExprPtr s_const = NULL;

    c1.reset(new ConstExpr(sreq->khole_start_seam_va, 8, 0));
    e1.reset(new SubExpr(e, c1));
    c2.reset(new ConstExpr(get_page_idx_shift, 8, 0));
    e2.reset(new ShrExpr(e1, c2));  //global khole idx
    c3.reset(new ConstExpr(sreq->khole_edit_start_seam_va, 8, 0));
    c4.reset(new ConstExpr(8, 8, 0));
    e3.reset(new MulExpr(e2, c4));
    khole_edit_addr.reset(new AddExpr(c3, e3));
    khole_edit_addr_conc = a_EFlagsMgr->ConcretizeExpression(khole_edit_addr, false);
    assert(khole_edit_addr_conc >= sreq->khole_edit_start_seam_va);

    std::cout << "khole_edit_addr_conc: 0x" << std::hex << khole_edit_addr_conc << std::endl;
    ulong pte = *(ulong *)khole_edit_addr_conc;
    m_VM->createSYMemObject(khole_edit_addr_conc, 8, 1, 1, pte, "pte");

    bool res;
    MemValue mv;
    mv.size = 8;
    mv.addr = khole_edit_addr_conc;
    mv.bsym = true;
    mv.isSymList = false;
    res = m_VM->readMemory (mv);
    assert(res);
    assert(mv.bsym);
    assert(mv.expr);

    c5.reset(new ConstExpr(PTE_TO_PA_MASK, 8, 0));
    mapped_pa.reset(new AndExpr(mv.expr, c5));

    ulong round;
    for(round = 0; round < SECURE_PAGE_COUNT; round++){
        if((sreq->secPages[round].mdata.base_pa != 0) && (sreq->secPages[round].mdata.td == sreq->td_owner_for_next_tdxcall)){
      
            c6.reset(new ConstExpr((sreq->secPages[round].mdata.base_pa << 12), 8, 0));
            e4.reset(new SubExpr(mapped_pa, c6));
            e5.reset(new EqualExpr(e4));

            if(s_const == NULL){
                s_const = e5;
            }
            else {
                e6.reset(new OrExpr(s_const, e5));
                s_const = e6;
            }
        }
    }
    std::cout << "page access sanitizer constraint : ";
    s_const->print();
    std::cout << std::endl;
    // assert(0);
    a_EFlagsMgr->m_Constraint.insert(s_const);
    // assert(0);
}

// void CAnalyze::pageMapSanitizer(ulong pte){
//     std::cout << "pageMapSanitizer\n";

//     ulong mod_running_td_ctx = sreq->td_owner_for_next_tdxcall;
// 	ulong executing_td_context;
	
// 	ulong pfn = ((pte & ~(HKID_MASK)) & PTE_TO_PA_MASK) >> 12;
//     ulong secure_page_idx = pfn - (TDX_TDMR0_START_PA >> 12);

// 	ulong hkid = (pte & HKID_MASK) >> HKID_START_BIT;

// 	securePage *sp = (securePage *)&sreq->secPages[secure_page_idx];
// 	ulong page_owner_td = sp->mdata.td;
// 	/*check if the hkid has a configured key on the platform*/
// 	if((hkid < TDX_GLOBAL_PRIVATE_HKID) || (hkid > (TDX_GLOBAL_PRIVATE_HKID + 2))){ /*we have 2 TDs*/
//         std::cout << "\npageMapSanitizer ERROR: UNCONFIGURED HKID " << std::dec << hkid << " , mapped page 0x" << std::hex << (pfn << 12) << std::endl;
// 	    a_EFlagsMgr->PrintConstraint();
//         endCurrentPathReason = PATH_ERROR;
//         endCurrentPath = true;
//         // assert(0);
//     }
// 	/*check if the hkid used is the valid hkid for the page*/
// 	else if(sp->mdata.hkid != hkid){
//         std::cout << "\npageMapSanitizer ERROR: INVALID HKID " << std::dec << hkid << " for page 0x" << std::hex << (pfn << 12) << std::endl;
// 	    a_EFlagsMgr->PrintConstraint();
//         endCurrentPathReason = PATH_ERROR;
//         endCurrentPath = true;        
//         // assert(0);
//     }
// 	/*check if the hkid used is valid in the current TD context*/
// 	else if(sp->mdata.td != sreq->td_owner_for_next_tdxcall){
//         std::cout << "\npageMapSanitizer ERROR: ILLEGAL page 0x" << std::hex << (pfn << 12) << " (Owner: TD_" << std::dec << page_owner_td << ") for currently serving TD: TD_" << mod_running_td_ctx << std::endl;
//         a_EFlagsMgr->PrintConstraint();
//         endCurrentPathReason = PATH_ERROR;
//         endCurrentPath = true;  
//         // assert(0);
// 	}
// }

void CAnalyze::pageMapChecker(uint reg_idx){

    std::cout << "pageAccessSanitizerSymbolic\n";
    ulong va = execData->last_conc_expr_val;
    assert(va >> 63);
    ulong pte_val = m_VM->m_EFlagsMgr->ConcretizeExpression(pte_expr);
    //get the pa
    ulong pa = pte_val & PTE_TO_PA_MASK;

    //get the keyid used to map this pa for this va
    KVExprPtr cons1 = NULL;
    KVExprPtr cons2 = NULL;
    KVExprPtr cons3 = NULL;
    KVExprPtr exp1 = NULL;
    KVExprPtr exp2 = NULL;
    KVExprPtr exp3 = NULL;
    KVExprPtr exp_pass = NULL;
    KVExprPtr exp_fail = NULL;

    cons1.reset(new ConstExpr(HKID_MASK, 8, 0));
    cons2.reset(new ConstExpr(HKID_START_BIT, 8, 0));
    exp1.reset(new AndExpr(pte_expr, cons1));  
    exp2.reset(new ShrExpr(exp1, cons2));//hkid

    std::cout << "hkid used to map the currently used va: \n";   
    exp2->print();
    std:cout << std::endl;

    //get the keyid used to encrypt this va
	ulong hkid_encrypted; //hkid used to encrypt the page
	ulong pfn = pa >> 12;
	ulong secure_page_idx = pfn - (TDX_TDMR0_START_PA >> 12);
	securePage *sp = (securePage *)&sreq->secPages[secure_page_idx];
    hkid_encrypted = sp->mdata.hkid;

    //compare
    cons3.reset(new ConstExpr(hkid_encrypted, 8, 0));
    exp3.reset(new SubExpr(exp2, cons3));

    //passing constraint
    exp_pass.reset(new EqualExpr(exp3));

    //failing constraint
    exp_fail.reset(new DistinctExpr(exp3));


    std::cout << "sani passing constraint: \n";
    exp_pass->print();
    std::cout << std::endl;

    std::cout << "sani failing constraint: \n";
    exp_fail->print();
    std::cout << std::endl;

    //solve for failing constraint
    // a_EFlagsMgr->m_Constraint.insert(exp_fail);
    a_EFlagsMgr->one_constraint.insert(exp_fail);
    a_EFlagsMgr->SolveOneConstraint();

    // a_EFlagsMgr->one_constraint.insert(exp_pass);
    // a_EFlagsMgr->SolveOneConstraint();

    std::cout << "end of page access checker" << std::endl;

    return;
}
void CAnalyze::pageMapSanitizerSymbolic(ulong reg_idx){

    bool res;
    RegValue rv;
    rv.indx = reg_idx;
    rv.size = 8;
    rv.isSymList = false;
    res = m_VM->readRegister(rv);
    assert(res);

    std::cout << "pageMapSanitizerSymbolic\n";
    KVExprPtr e = rv.expr;
    assert(e);
    std::cout << "EPTE : ";
    rv.expr->print();
    std::cout << std::endl;

    rv.indx = reg_idx;
    rv.size = 8;
    rv.isSymList = false;
    res = m_VM->readRegister(rv);
    assert(res);

    KVExprPtr e1 = NULL;
    KVExprPtr e2 = NULL;
    KVExprPtr e3 = NULL;
    KVExprPtr e4 = NULL;
    KVExprPtr e5 = NULL;
    KVExprPtr e6 = NULL;
    KVExprPtr e7 = NULL;
    KVExprPtr s_const = NULL;


    ulong hkid_pa = 0;
    ulong round = 0;
    // std::cout << "0x" << std::hex << (HKID_MASK | PTE_TO_PA_MASK) << std::endl;
    for(round = 0; round < SECURE_PAGE_COUNT; round++){
        // std::cout << "\nround " << std::dec << round << " " << std::hex << sreq->secPages[round].raw << std::endl;
        // std::cout << "Address 0x" << std::hex << (unsigned long)&sreq->secPages[round] << std::endl;

        if((sreq->secPages[round].mdata.base_pa != 0) && (sreq->secPages[round].mdata.td == sreq->td_owner_for_next_tdxcall)){
            hkid_pa = sreq->secPages[round].raw & (HKID_MASK | PTE_TO_PA_MASK);
            std::cout << "hkid_pa: 0x" << std::hex << hkid_pa << std::endl;
            e1.reset(new ConstExpr(hkid_pa, 8, 0));
            e2.reset(new ConstExpr((HKID_MASK | PTE_TO_PA_MASK), 8, 0));
            e3.reset(new AndExpr(rv.expr, e2));
            e4.reset(new SubExpr(e3, e1));
            e5.reset(new EqualExpr(e4));

            if(s_const == NULL){
                s_const = e5;
            }
            else {
                e6.reset(new OrExpr(s_const, e5));
                s_const = e6;
            }
            // std::cout << "sanitizer constraint : ";
            // s_const->print();
            // std::cout << std::endl;
            // assert(0);
            // assert(0);
        }
    }
    std::cout << "sanitizer constraint : ";
    s_const->print();
    std::cout << std::endl;
    // assert(0);
    a_EFlagsMgr->m_Constraint.insert(s_const);

    // e1.reset(new ConstExpr(HKID_MASK, 8, 0));
    // e2.reset(new AndExpr(e1, rv.expr));
    // e3.reset(new ConstExpr(HKID_START_BIT, 8, 0));
    // e4.reset(new Shl_SalExpr(e3, e2));
    // ulong current_td_hkid = 5;
    // e5.reset(new ConstExpr(current_td_hkid, 8, 0));
    // e6.reset(new SubExpr(e4, e5));
    // e7.reset(new EqualExpr(e6));
    // a_EFlagsMgr->m_Constraint.insert(e7);
    // // e2.reset(new )

    // KVExprPtr e8 = NULL;
    // KVExprPtr e9 = NULL;
    // KVExprPtr e10 = NULL;
    // KVExprPtr e11 = NULL;
    // KVExprPtr pg_pa = NULL;
    // e8.reset(new ConstExpr(PTE_TO_PA_MASK, 8, 0));
    // pg_pa.reset(new AndExpr(e1, rv.expr));
    // e9.reset(new ConstExpr(0x40004026, 8, 0));
    // e10.reset(new SubExpr(pg_pa, e9));
    // e11.reset(new EqualExpr(e10));
    // a_EFlagsMgr->m_Constraint.insert(e11);

}

//-----Analyzer Begins here -----------------------------------------------------------------------------------------------------------

ulong map_pa_ret = 0;
ulong map_pa_addr = 0;
ulong keyid_pa_in = 0;
ulong mapping_type_in = 0;
ulong mapping_permission_in = 0;
tdxmod_keyhole_state_t *khs;

std::map<int, KVExprPtr> s_keyhole_keyid_pa_sym_map;
std::map<int, KVExprPtr> s_keyhole_ref_sym_map;

std::map<int, KVExprPtr> e_keyhole_keyid_pa_sym_map;
std::map<int, KVExprPtr> e_keyhole_ref_sym_map;

int CAnalyze::onEndOfInsExec(){ //analysis at the end of each instruction


    if(m_regs->regs.rip == map_pa_ret){
        
        std::cout << "at map_pa_ret():0x" << std::endl; 
        endCurrentPath = true;
        assert(endCurrentPathReason == PATH_NONE);
        endCurrentPathReason = PATH_FUNCTION_RET;
        // std::cout << "\nEnd of cur path .... SEAMRET: SUCCESS" << std::endl; //just to support post processing
        // std::cout << "\npath constraints : " << std::endl;
        // a_EFlagsMgr->PrintConstraint();
        // a_EFlagsMgr->SolveConstraints();

        // //print hole ref count expr-----------------------------
        // MemValue mv;
        // int idx = 0;
        // while(idx < 128){
        //     mv.addr = (ulong)&khs->keyhole_array[idx].ref_count;
        //     mv.size = 8;
        //     mv.isSymList = false;
        //     bool res_2 = m_VM->readMemory(mv);
        //     assert(res_2);

        //     if(mv.bsym){
        //         std::cout << " idx " << std::dec << idx << " k_refs_expr: ";
        //         mv.expr->print();
        //         std::cout << std::endl;
        //     }
        //     else{
        //         std::cout << " idx " << std::dec << idx << " k_refs: " << mv.i64 << std::endl;
        //     }
        //     idx++;
        // }
        // std::cout << std::endl;

        // //read total ref count as well-------------------------
        // mv.addr = (ulong)&khs->total_ref_count;
        // mv.size = 8;
        // mv.isSymList = false;
        // bool res_2 = m_VM->readMemory(mv);
        // assert(res_2);

        // if(mv.bsym){
        //     std::cout << "tot_refs_expr: ";
        //     mv.expr->print();
        //     std::cout << std::endl;
        // }
        // else{
        //     std::cout << "tot_refs: " << mv.i64 << std::endl;
        // }
        // std::cout << std::endl;
        // std::cout << std::endl;
    }
    
    if(endCurrentPath){
        std::cout << "\n##End of cur path" << std::endl;
        std::cout << "\npath constraints : " << std::endl;
        a_EFlagsMgr->PrintConstraint();
        std::cout << std::endl;
        onPathEnd();
    }

    return 0;
}

int CAnalyze::onBeforeCIESIE(){
    return 0;
} 

KVExprPtr CAnalyze::readSymMem(unsigned long addr, ulong size, ulong &val){

    MemValue mv ;
    mv.addr = addr;
    mv.size = size;
    mv.isSymList = false ;
    bool res = m_VM->readMemory(mv);
    assert(res);
    if(mv.bsym){
        assert(mv.expr);
        return mv.expr;
    }
    else{
        val = mv.i64;
        return NULL;
    }
}

int CAnalyze::onPathEnd(){

    std::cout << "at path end handler" << std::endl;
    unsigned long hkid_pa_mapped;
    bool is_new_mapping = false;
    int idx;
    bool is_ref_c_concrete = false;
    bool is_ref_c_unmodified;
    bool is_ref_c_increased_by_one;
    int ref_c_modified_khole_count = 0;
    ulong conc_val;
    int modified_ref_c_idx = -1;

    // if(endCurrentPathReason == PATH_FUNCTION_RET){
    //     std::cout << "at map_pa_ret()" << std::endl; 
    // }

    if(m_regs->regs.rip == map_pa_ret){
        // std::cout << "at map_pa_ret()" << std::endl; 
        // endCurrentPath = true;
        std::cout << "\nEnd of cur path ...." << std::endl; //just to support post processing
        std::cout << "\npath constraints : " << std::endl;
        // a_EFlagsMgr->PrintConstraint();
        // a_EFlagsMgr->SolveConstraints();

        hkid_pa_mapped = sreq->last_khole_pte & (HKID_MASK | PTE_TO_PA_MASK);
        sreq->last_khole_pte = 0;
        std::cout << "hkid_pa_mapped: 0x" << std::hex << hkid_pa_mapped << std::endl;
        std::cout << "keyid_pa_in: 0x" << std::hex << keyid_pa_in << std::endl;

        if(hkid_pa_mapped == keyid_pa_in){
            std::cout << "\nEnd of cur path .... AT FUNCTION RET: NEW MAPPING" << std::endl; //just to support post processing
            is_new_mapping = true;
            std::cout << "new keyhole mapped for keyid+pa" << std::endl;
        }
        else{
            std::cout << "\nEnd of cur path .... AT FUNCTION RET: EXISTING MAPPING" << std::endl; //just to support post processing
            std::cout << "existing keyhole mapping used for keyid+pa" << std::endl;

        }

        //fill end expr maps and analyze
        idx = 0;
        while(idx < 128){
            std::cout << "-------------------khole idx: " << std::dec << idx << std::endl;
            KVExprPtr keyid_pa_sym = readSymMem((ulong)&khs->keyhole_array[idx].mapped_pa, 8, conc_val);
            
            KVExprPtr c;
            //we do not expect the keyid_pa to be updated. can skip this. ?
            if(keyid_pa_sym == NULL){

                c.reset(new ConstExpr(conc_val, 8, 0));
                e_keyhole_keyid_pa_sym_map[idx] = c;

            }
            else{
                e_keyhole_keyid_pa_sym_map[idx] = keyid_pa_sym;
            }

            KVExprPtr ref_c_sym = readSymMem((ulong)&khs->keyhole_array[idx].ref_count, 8, conc_val);
            KVExprPtr c0;
            KVExprPtr e0 = NULL;
            KVExprPtr e1 = NULL;
            KVExprPtr c4;
            KVExprPtr e5;
            KVExprPtr e6;

            if(ref_c_sym == NULL){ //if the end_ref_c is concrete
                if(is_new_mapping){

                    if(conc_val != 1){ //if end_ref_c is concrete, it must be 1
                        std::cout << "ERROR: if ref count is concrete, it must be 1" << std::endl;
                        assert(0);
                    }
                    std::cout << "OK: if ref count is modified to a concrete value: 1" << std::endl;
                    is_ref_c_concrete = true;
                    is_ref_c_unmodified = false;
                    ref_c_modified_khole_count++;
                    modified_ref_c_idx = idx;
                    c0.reset(new ConstExpr(conc_val, 8, 0));
                    e_keyhole_ref_sym_map[idx] = c0;
                }
                else{
                    std::cout << "ERROR: ref count can not be concrete (1), if not a new mapping" << std::endl;
                    assert(0);
                }
            }
            else{  //if the end_ref_c is symbolic,  check if (start_ref_c = end_ref_c)
                e_keyhole_ref_sym_map[idx] = ref_c_sym;
            
                e0.reset(new SubExpr(s_keyhole_ref_sym_map[idx], e_keyhole_ref_sym_map[idx]));
                e1.reset(new EqualExpr(e0));

                std::set<KVExprPtr> tmp_constraint1;
                tmp_constraint1.insert(e1);

                // if(is_new_mapping){
                //     c4.reset(new ConstExpr(0, 8, 0));
                //     e5.reset(new SubExpr(s_keyhole_ref_sym_map[idx], c4));
                //     e6.reset(new EqualExpr(e5));
                //     tmp_constraint1.insert(e6);
                // }

                std::cout << "Expression to evaluate: "; //ref_c_start = ref_c_end   >> true if unmodified
                e1->print();
                // std::cout << "  AND  ";
                // e6->print();
                std::cout << std::endl;
                
                is_ref_c_unmodified = a_EFlagsMgr->m_Z3Handler->Z3ConstraintChecking(tmp_constraint1);

                std::cout << "initial expr: ";
                s_keyhole_ref_sym_map[idx]->print();
                std::cout << "\tend expr: ";
                e_keyhole_ref_sym_map[idx]->print();
                std::cout << "\tis_ref_c_unmodified: " << is_ref_c_unmodified << std::endl;
            }

            KVExprPtr c1 = NULL;
            KVExprPtr e2 = NULL;
            KVExprPtr e3 = NULL;
            KVExprPtr e4 = NULL;

            if(!is_ref_c_unmodified && !is_ref_c_concrete){   //if modified but not to a concrete value. (We've already handled the conc scenario above)
                ref_c_modified_khole_count++;
                modified_ref_c_idx = idx;

                //now check if increased by exactly 1
                ulong expected_ref_c_increase = 1;
                c1.reset(new ConstExpr(expected_ref_c_increase,8,0));
                e2.reset(new AddExpr(s_keyhole_ref_sym_map[idx], c1));
                e3.reset(new SubExpr(e_keyhole_ref_sym_map[idx], e2));
                e4.reset(new EqualExpr(e3));
                std::cout << "Expression to evaluate: ";  //ref_c_end = ref_c_start + 1    >> true if correctly modified
                e4->print();
                std::cout << std::endl;
                std::set<KVExprPtr> tmp_constraint2;
                tmp_constraint2.insert(e4);
                is_ref_c_increased_by_one = a_EFlagsMgr->m_Z3Handler->Z3ConstraintChecking(tmp_constraint2);  //is only increased by 1

                if(!is_ref_c_increased_by_one){
                    std::cout << "ERROR: incorrect increase in ref count" << std::endl;
                    assert(0);
                }
                else{
                    std::cout << "OK: correct increase in ref count" << std::endl;
                }
            }
            else{
                std::cout << "OK: no increase in ref count" << std::endl;
            }

            idx++;
        }
        assert(ref_c_modified_khole_count == 1); //there should only be one ref_c modification

        std::cout << std::endl;

        //now we check if the ref count has been modified in the correct keyhole: so need to look at the path constraint.
        //if ref_c has been modified, 
            // if not a new mapping: the keyid_pa must match the keyid_pa_in
                    //so path constraint must have predicate (keyid_pa = keyid_pa_in)
                    //so (path constraint) AND (keyid_pa != keyid_pa_in)  ==>> must be false
            // if a new mapping: Any keyid_pa in the path constraint must not match the key_id_pa_in
                    //if :path constraint has the predicate (keyid_pa = keyid_pa_in), then RW_in != RW_keyhole
                    //else : the path constraint must not have the predicate (keyid_pa = keyid_pa_in)
                    //so evaluare (path constraint) AND (keyid_pa != keyid_pa_in)  
                        //if true: predicate, (keyid_pa = keyid_pa_in) is not in the PC : OK
                        //if false: predicate, (keyid_pa = keyid_pa_in) is in the PC, 
                                    //then Mapping_access_permissions or mem_type must mismatch  must mismatch (RW_in != RW_keyhole) or (type_in != type_keyhole)

        assert(modified_ref_c_idx != -1);
        KVExprPtr a0 = NULL;
        KVExprPtr b0 = NULL;
        KVExprPtr b1 = NULL;

        a0.reset(new ConstExpr(keyid_pa_in, 8, 0));
        b0.reset(new SubExpr(s_keyhole_keyid_pa_sym_map[modified_ref_c_idx], a0));
        b1.reset(new DistinctExpr(b0));

        std::set<KVExprPtr> tmp_constraint3;
        tmp_constraint3.insert(a_EFlagsMgr->m_Constraint.begin(), a_EFlagsMgr->m_Constraint.end());
        tmp_constraint3.insert(b1);

        if(!a_EFlagsMgr->m_Z3Handler->Z3ConstraintChecking(tmp_constraint3)){
            if(!is_new_mapping){ //if an existing mapping has been used, ok
                std::cout << "OK: correct keyhole has been incremented" << std::endl;
            }
            else{ //not a new mapping
                if((mapping_permission_in != khs->keyhole_array[modified_ref_c_idx].is_writable) ||
                    (mapping_type_in != khs->keyhole_array[modified_ref_c_idx].is_wb_memtype))
                {
                    std::cout << "OK: correct keyhole (not in the cache), has been incremented1" << std::endl;
                }
                else{
                    std::cout << "ERROR: correct keyhole has not been incremented1" << std::endl;
                }
            }
        }
        else{
            if(is_new_mapping){ //if an existing mapping has been used, ok
                std::cout << "OK: correct keyhole (not in the cache), has been incremented2" << std::endl;
            }
            else{
                std::cout << "ERROR: correct keyhole has not been incremented2" << std::endl;
            }
        }

        //now check if the resultant VA is consistant with the keyhole index
        ulong expected_va = lp_keyhole_va_base + 4096*modified_ref_c_idx;
        std::cout << "expected_va: 0x" << std::hex << expected_va << " returned va: 0x" << m_regs->regs.rax << std::endl;
        if(m_regs->regs.rax != expected_va){
            std::cout << "ERROR: returned va does not match the expected" << std::endl;
            assert(0);
        }
        else{
            std::cout << "OK: returned va does match the expected" << std::endl;
        }

        e_keyhole_ref_sym_map.clear();
        // //print hole ref count expr-----------------------------
        // MemValue mv;
        // int idx = 0;
        // while(idx < 128){
        //     mv.addr = (ulong)&khs->keyhole_array[idx].ref_count;
        //     mv.size = 8;
        //     mv.isSymList = false;
        //     bool res_2 = m_VM->readMemory(mv);
        //     assert(res_2);

        //     if(mv.bsym){
        //         std::cout << " idx " << std::dec << idx << " k_refs_expr: ";
        //         mv.expr->print();
        //         std::cout << std::endl;
        //     }
        //     else{
        //         std::cout << " idx " << std::dec << idx << " k_refs: " << mv.i64 << std::endl;
        //     }
        //     idx++;
        // }
        // std::cout << std::endl;

        // //read total ref count as well-------------------------
        // mv.addr = (ulong)&khs->total_ref_count;
        // mv.size = 8;
        // mv.isSymList = false;
        // bool res_2 = m_VM->readMemory(mv);
        // assert(res_2);

        // if(mv.bsym){
        //     std::cout << "tot_refs_expr: ";
        //     mv.expr->print();
        //     std::cout << std::endl;
        // }
        // else{
        //     std::cout << "tot_refs: " << mv.i64 << std::endl;
        // }
        // std::cout << std::endl;
        // std::cout << std::endl;
    }
    else{
        std::cout << "error path" << std::endl;
        std::cout << "\nEnd of cur path .... error" << std::endl; //just to support post processing
        std::cout << "\npath constraints : " << std::endl;
        a_EFlagsMgr->PrintConstraint();
        std::cout << "last constraint : " << std::endl;
        a_EFlagsMgr->last_constraint->print();
    }

    return 0;
}

int CAnalyze::analyztsHub(int anaPoint) { //analysis of KRover's SE by analyzer goes through this hub
    // std::cout << "at analyztsHub" << std::endl;
    switch(anaPoint){
        case ON_END_OF_INS_EXEC:
        {
            return CAnalyze::onEndOfInsExec();
        }   break;
        case ON_BFR_CIE_OR_SIE:
        {
            return CAnalyze::onBeforeCIESIE();
            break;
        }
        case ON_PATH_END:
        {
            return CAnalyze::onPathEnd();
            break;
        }
        default:
            break;
    }
    return 0;
}

KVExprPtr CAnalyze::readSymReg(uint reg_idx){
    RegValue rv;
    rv.indx = reg_idx;
    rv.size = 8;
    rv.isSymList = false;
    bool res = m_VM->readRegister(rv);
    assert(res);
    assert(rv.bsym);

    return rv.expr;
}

bool CAnalyze::concSymReg(uint reg_idx, ulong val){
    RegValue rv;
    rv.indx = reg_idx;
    rv.size = 8;
    rv.isSymList = false;
    rv.bsym = false;
    rv.i64 = val;
    bool res = m_VM->writeRegister(rv);
    assert(res);

    return true;
}

ulong CAnalyze::keyidOwnerToKeyid(uint8_t owner){
    // std::cout << "owner: " << (int)owner << std::endl;
    switch (owner)
    {
    case 0: //TD_0
        return (TDX_GLOBAL_PRIVATE_HKID) + 1;
        break;
    case TDX_MOD: //Module
        return (TDX_GLOBAL_PRIVATE_HKID);
        break;
    default:
        assert(0);
        break;
    }
    return 0;
}


bool CAnalyze::beginAnalysis(ulong addr) { //Analysis start

    m_regs = (struct MacReg*)m_VM->getPTRegs();
    std::cout << "at beginAnalysis" << std::endl;
    MemValue mv;
    bool ret;
    ulong conc_mem_val;

    lp_keyhole_va_base = sreq->khole_start_seam_va + sreq->current_lp*(PG_SZ_4K * 128);
    lp_khole_edit_base_va = sreq->khole_edit_start_seam_va + sreq->current_lp*8*128;

    //this is just to control and debug for now
    // m_regs->regs.rdi += 0x100000;

    std::cout << "rip:0x" << std::hex << m_regs->regs.rip << std::endl;

    execData->start_rsp = m_regs->regs.rsp;
    keyid_pa_in = m_regs->regs.rdi;
    mapping_permission_in = m_regs->regs.rsi;
    mapping_type_in = m_regs->regs.rdx;

    map_pa_ret = *(ulong *)(m_regs->regs.rsp);
    std::cout << "map_pa_ret adr:0x" << map_pa_ret << std::endl;

    // m_VM->createSYRegObject(x86_64::esi, 4, 1, 1, m_regs->regs.rsi, "in_RW");
    // std::cout << "type:" << std::dec << m_regs->regs.rsi << std::endl;

    // ulong pa = m_regs->regs.rdi;
    // m_VM->createSYRegObject(x86_64::rdi, 8, 1, 1, pa, "in_pa");
    // std::cout << "pa" << std::hex << pa << std::endl;

    //symbolize keyhole state
    khs = (tdxmod_keyhole_state_t *)sreq->khole_state_seam_va;
    std::cout << "total refs " << std::dec << khs->total_ref_count << std::endl;
    std::cout << "kh0 pa 0x" << std::hex << khs->keyhole_array[0].mapped_pa << std::endl;

    // m_VM->createSYMemObject((ulong)&khs->total_ref_count, 8, 1, 1, khs->total_ref_count, "tot_r");

    int idx = 0;
    std::string sym_hkid_pa_prefix = "pa_";
    std::string sym_ref_c_prefix = "r_";
    std::string is_wr_prefix = "RW_";
    std::string is_wb_prefix = "WB_";

    while(idx < 128){
        std::string sym_str = sym_hkid_pa_prefix + std::to_string(idx);
        const char* sym_hkid_pa = sym_str.c_str();
        // createSymbolicMemory((ulong)&khs->keyhole_array[idx].mapped_pa, 8, 1, 1, khs->keyhole_array[idx].mapped_pa, sym_hkid_pa);
        m_VM->createSYMemObject((ulong)&khs->keyhole_array[idx].mapped_pa, 8, 1, 1, khs->keyhole_array[idx].mapped_pa, sym_hkid_pa);
        // std::cout << "sym_hkid_pa done" << std::endl;

        KVExprPtr keyid_pa_sym = readSymMem((ulong)&khs->keyhole_array[idx].mapped_pa, 8, conc_mem_val);
        s_keyhole_keyid_pa_sym_map[idx] = keyid_pa_sym;

        sym_str = sym_ref_c_prefix + std::to_string(idx);
        const char* sym_ref_ct = sym_str.c_str();
        // createSymbolicMemory((ulong)&khs->keyhole_array[idx].ref_count, 8, 1, 1, khs->keyhole_array[idx].ref_count, sym_ref_ct);
        m_VM->createSYMemObject((ulong)&khs->keyhole_array[idx].ref_count, 8, 1, 1, khs->keyhole_array[idx].ref_count, sym_ref_ct);
        // std::cout << "sym_ref_ct done" << std::endl;

        KVExprPtr ref_c_sym = readSymMem((ulong)&khs->keyhole_array[idx].ref_count, 8, conc_mem_val);
        s_keyhole_ref_sym_map[idx] = ref_c_sym;

        // sym_str = is_wr_prefix + std::to_string(idx);
        // const char* sym_rw = sym_str.c_str();
        // m_VM->createSYMemObject((ulong)&khs->keyhole_array[idx].is_writable, 1, 1, 1, khs->keyhole_array[idx].is_writable, sym_rw);
        // // std::cout << "sym_rw done" << std::endl;

        // sym_str = is_wb_prefix + std::to_string(idx);
        // const char* sym_wb = sym_str.c_str();
        // m_VM->createSYMemObject((ulong)&khs->keyhole_array[idx].is_wb_memtype, 1, 1, 1, khs->keyhole_array[idx].is_wb_memtype, sym_wb);
        // // std::cout << "sym_wb done" << std::endl;

        idx++;
    }
    std::cout << "eee" << std::endl;

    //now generate constraints for security policies
//     Security Policy 1: KeyID Validity					
// 	The KeyID must be configured and valid on the platform.				
					
// Security Policy 2: Page Ownership Scope					
// 	The physical page must be valid in the current context — i.e., it must belong to either the current TD or the Module.				
					
// Security Policy 3: Ownership-KeyID Mapping					
// 	The physical page must be mapped using the correct KeyID for its ownership:				
// 		TD pages → TD KeyID			
// 		Module pages (including the TDR) → Module KeyID			


    m_VM->createSYRegObject(x86_64::rdi, 8, 1,1, m_regs->regs.rdi, "keyid_pa");
    KVExprPtr e = readSymReg(x86_64::rdi);
    e->print();

    KVExprPtr c1, c2, c3, c4, c5, e1, e2, e3, e4, e5, e6;
    ulong max_key_id = TDX_GLOBAL_PRIVATE_HKID + 2;
    c1.reset(new ConstExpr(max_key_id, 8, 0));
    c2.reset(new ConstExpr((TDX_GLOBAL_PRIVATE_HKID), 8, 0));
    c3.reset(new ConstExpr((HKID_MASK), 8 , 0));
    c4.reset(new ConstExpr((HKID_START_BIT), 8 , 0));
    e5.reset(new AndExpr(e, c3));
    e6.reset(new ShrExpr(e5, c4)); //KEyID
    e1.reset(new UgeExpr(e6, c1));
    e2.reset(new UltExpr(e6, c2));
    e3.reset(new OrExpr(e1, e2)); //policy 1: failure constraint : e > max_key_id  || e < global_key_id
    std::cout << "Policy 1 violation expression: ";
    e3->print();
    std::cout << std::endl;
    a_EFlagsMgr->m_Constraint.insert(e3);
    a_EFlagsMgr->SolveConstraints();
    a_EFlagsMgr->m_Constraint.clear();

    // c3.reset(new ConstExpr())


    //Pa = tdpage or pa = Module page
    // securePage secPages[SECURE_PAGE_COUNT];

    KVExprPtr p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, s0;
    KVExprPtr s = NULL;

    p0.reset(new ConstExpr((PTE_TO_PA_MASK), 8, 0));
    p1.reset(new AndExpr(e, p0)); //mapped_pa

    ulong p_idx = 0;
    ulong p_pa;
    int count = 0;
    while(p_idx < SECURE_PAGE_COUNT){

        if(sreq->secPages[p_idx].mdata.base_pa > 0){
            if((sreq->secPages[p_idx].mdata.td == TDX_MOD) || (sreq->secPages[p_idx].mdata.td == 0)){
                p_pa = sreq->secPages[p_idx].mdata.base_pa << 12;
                p2.reset(new ConstExpr(p_pa, 8, 0));
                p3.reset(new SubExpr(p1, p2));
                p4.reset(new DistinctExpr(p3)); //page is not a TD or a Module page

                if(s == NULL){
                    s = p4;
                }
                else{
                    p5.reset(new AndExpr(s, p4));
                    s = p5;
                }
            }
        }
        p_idx++;
    }
    std::cout << "Policy 2 violation expression solving: ";
    s->print();  //too long to print
    std::cout << std::endl;
    a_EFlagsMgr->m_Constraint.insert(s);
    a_EFlagsMgr->SolveConstraints();
    a_EFlagsMgr->m_Constraint.clear();

    p_idx = 0;
    s = NULL;
    while(p_idx < SECURE_PAGE_COUNT){

        if(sreq->secPages[p_idx].mdata.base_pa > 0){
            if((sreq->secPages[p_idx].mdata.td == TDX_MOD) || (sreq->secPages[p_idx].mdata.td == 0)){
                p_pa = sreq->secPages[p_idx].mdata.base_pa << 12;
                // std::cout << "p_pa: 0x" << std::hex << p_pa << std::endl;
                p2.reset(new ConstExpr(p_pa, 8, 0));
                p3.reset(new SubExpr(p1, p2));
                p4.reset(new EqualExpr(p3)); //pa == p_pa

                ulong p_keyid = keyidOwnerToKeyid((uint8_t)sreq->secPages[p_idx].mdata.hkid_owner);
                p5.reset(new ConstExpr(p_keyid, 8, 0));
                p6.reset(new SubExpr(e6, p5));
                p7.reset(new DistinctExpr(p6)); //keyid != p_keyid
                p8.reset(new AndExpr(p4, p7)); //pa == p_pa  AND  keyid != p_keyid
                // p9.reset(new DistinctExpr(p8));

                if(s == NULL){
                    s = p8;
                }
                else{
                    p10.reset(new OrExpr(s, p8));
                    s = p10;
                }
            }
        }
        p_idx++;
    }
    std::cout << "Policy 3 violation expression solving: ";
    s->print();  //too long to print
    std::cout << std::endl;
    a_EFlagsMgr->m_Constraint.insert(s);
    a_EFlagsMgr->SolveConstraints();
    a_EFlagsMgr->m_Constraint.clear();

    p10.reset(new ConstExpr((keyid_pa_in & PTE_TO_PA_MASK), 8, 0));
    p9.reset(new SubExpr(p1, p10));
    p8.reset(new EqualExpr(p9));
    p7.reset(new AndExpr(s, p8));
    std::cout << "Policy 3 violation expression solving with pa fized: ";
    // s->print();  
    // std::cout << std::endl;
    a_EFlagsMgr->m_Constraint.insert(p7);
    a_EFlagsMgr->SolveConstraints();
    a_EFlagsMgr->m_Constraint.clear();

    

    //clear the m_constraint and concretize the symbol
    a_EFlagsMgr->m_Constraint.clear();
    concSymReg(x86_64::rdi, keyid_pa_in);
exit(0);

    // setExecProfileSinglePath();
    setExecProfileMultiPath();

    
    dispatch_count++;

    return m_Thin->processFunction(addr);
}













